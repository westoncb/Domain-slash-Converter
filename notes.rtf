{\rtf1\ansi\ansicpg1252\cocoartf1347\cocoasubrtf570
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww12600\viewh10200\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural

\f0\fs28 \cf0 The problem with the Domain/Converter system as it is now is that the \'91control flow\'92 is defined inside of particular Domains; instead, what you want is to have a higher level region of code that can describe this flow of instantiated data structures through Domains, which knows about all of the relevant domains and can describe their configuration in a purely declarative fashion, like this:\
\
DomainX <ConverterA> DomainY\
DomainY [Pull] DomainX (when\'85.?) I don\'92t know how the \'91when\'92 clause works yet.\
\
Then there\'92s a special domain for outside of the program, which we\'92ll call OuterDomain, and it\'92s capable of \'91generating\'92 inputs to the program, via textual data from the command line or network events, or mouse/keyboard events. The \'91initial domain\'92 of a program always pushes or pulls on the OuterDomain.\
\
Inside of domains there\'92s a subset of the language for specifying data structures (in this usage, \'91data structure\'92 ranges from}